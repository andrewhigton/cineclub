{"ast":null,"code":"'use strict';\n\nvar makeRequest = require('./makeRequest');\n\nvar utils = require('./utils');\n\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  var promiseCache = {\n    currentPromise: null\n  };\n  var listPromise = firstPagePromise;\n  var i = 0;\n\n  function iterate(listResult) {\n    if (!(listResult && listResult.data && typeof listResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n\n    if (i < listResult.data.length) {\n      var value = listResult.data[i];\n      i += 1;\n      return {\n        value: value,\n        done: false\n      };\n    } else if (listResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      var lastId = getLastId(listResult);\n      listPromise = makeRequest(self, requestArgs, spec, {\n        starting_after: lastId\n      });\n      return listPromise.then(iterate);\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, function (resolve, reject) {\n      return listPromise.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  var autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  var autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  var autoPaginationMethods = {\n    autoPagingEach: autoPagingEach,\n    autoPagingToArray: autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: function () {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: function () {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n}\n\nmodule.exports.makeAutoPaginationMethods = makeAutoPaginationMethods;\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\n\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  } // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n\n\n  return '@@asyncIterator';\n}\n\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n\n  var onDone = args[1];\n\n  if (typeof onDone !== 'function') {\n    throw Error('The second argument to autoPagingEach, if present, must be a callback function; receieved ' + typeof onDone);\n  }\n\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\n\n\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n\n  var onItem = args[0];\n\n  if (typeof onItem !== 'function') {\n    throw Error('The first argument to autoPagingEach, if present, must be a callback function; receieved ' + typeof onItem);\n  } // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n\n\n  if (onItem.length === 2) {\n    return onItem;\n  }\n\n  if (onItem.length > 2) {\n    throw Error('The `onItem` callback function passed to autoPagingEach must accept at most two arguments; got ' + onItem);\n  } // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n\n\n  return function _onItem(item, next) {\n    var shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\n\nfunction getLastId(listResult) {\n  var lastIdx = listResult.data.length - 1;\n  var lastItem = listResult.data[lastIdx];\n  var lastId = lastItem && lastItem.id;\n\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\n\n\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n\n  promiseCache.currentPromise = new Promise(cb).then(function (ret) {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function\n    /* onItem?, onDone? */\n  autoPagingEach() {\n    var args = [].slice.call(arguments);\n    var onItem = getItemCallback(args);\n    var onDone = getDoneCallback(args);\n\n    if (args.length > 2) {\n      throw Error('autoPagingEach takes up to two arguments; received:', args);\n    }\n\n    var autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem);\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\n\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    var limit = opts && opts.limit;\n\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, eg; `autoPagingToArray({limit: 1000});`.');\n    }\n\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n\n    var promise = new Promise(function (resolve, reject) {\n      var items = [];\n      autoPagingEach(function (item) {\n        items.push(item);\n\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(function () {\n        resolve(items);\n      }).catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\n\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise(function (resolve, reject) {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n\n      var item = iterResult.value;\n      return new Promise(function (next) {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(function (shouldContinue) {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}","map":{"version":3,"sources":["/Users/andrewhigton/Documents/code/typescript/cineclub/node_modules/stripe/lib/autoPagination.js"],"names":["makeRequest","require","utils","makeAutoPaginationMethods","self","requestArgs","spec","firstPagePromise","promiseCache","currentPromise","listPromise","i","iterate","listResult","data","length","Error","value","done","has_more","lastId","getLastId","starting_after","then","undefined","asyncIteratorNext","memoizedPromise","resolve","reject","catch","autoPagingEach","makeAutoPagingEach","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","next","return","getAsyncIteratorSymbol","module","exports","Symbol","asyncIterator","getDoneCallback","args","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","lastIdx","lastItem","id","cb","Promise","ret","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","items","push","handleIteration","iterResult"],"mappings":"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","sourcesContent":["'use strict';\n\nvar makeRequest = require('./makeRequest');\nvar utils = require('./utils');\n\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  var promiseCache = {currentPromise: null};\n  var listPromise = firstPagePromise;\n  var i = 0;\n\n  function iterate(listResult) {\n    if (!(listResult && listResult.data && typeof listResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n\n    if (i < listResult.data.length) {\n      var value = listResult.data[i];\n      i += 1;\n      return {value: value, done: false};\n    } else if (listResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      var lastId = getLastId(listResult);\n      listPromise = makeRequest(self, requestArgs, spec, {starting_after: lastId});\n      return listPromise.then(iterate);\n    }\n    return {value: undefined, done: true};\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, function(resolve, reject) {\n      return listPromise\n        .then(iterate)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  var autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  var autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n\n  var autoPaginationMethods = {\n    autoPagingEach: autoPagingEach,\n    autoPagingToArray: autoPagingToArray,\n\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: function() {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: function() {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n}\n\nmodule.exports.makeAutoPaginationMethods = makeAutoPaginationMethods;\n\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\n\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\n\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n  var onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error('The second argument to autoPagingEach, if present, must be a callback function; receieved ' + typeof onDone);\n  }\n  return onDone;\n}\n\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  var onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error('The first argument to autoPagingEach, if present, must be a callback function; receieved ' + typeof onItem);\n  }\n\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n\n  if (onItem.length > 2) {\n    throw Error('The `onItem` callback function passed to autoPagingEach must accept at most two arguments; got ' + onItem);\n  }\n\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    var shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\n\nfunction getLastId(listResult) {\n  var lastIdx = listResult.data.length - 1;\n  var lastItem = listResult.data[lastIdx];\n  var lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then(function(ret) {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach(/* onItem?, onDone? */) {\n    var args = [].slice.call(arguments);\n    var onItem = getItemCallback(args);\n    var onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error('autoPagingEach takes up to two arguments; received:', args);\n    }\n\n    var autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem);\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  }\n}\n\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    var limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, eg; `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    var promise = new Promise(function(resolve, reject) {\n      var items = [];\n      autoPagingEach(function(item) {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(function() {\n        resolve(items);\n      }).catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  }\n}\n\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise(function(resolve, reject) {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n\n      var item = iterResult.value;\n      return new Promise(function(next) {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(function(shouldContinue) {\n        if (shouldContinue === false) {\n          return handleIteration({done: true});\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\n"]},"metadata":{},"sourceType":"script"}